<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Marcin Pędzimąż]]></title>
  <link href="http://noxytrux.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://noxytrux.github.io/"/>
  <updated>2014-10-04T23:48:28+02:00</updated>
  <id>http://noxytrux.github.io/</id>
  <author>
    <name><![CDATA[Marcin Pędzimąż]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Godrays for mobile devices]]></title>
    <link href="http://noxytrux.github.io/blog/2014/10/04/godrays-for-mobile-devices/"/>
    <updated>2014-10-04T18:00:41+02:00</updated>
    <id>http://noxytrux.github.io/blog/2014/10/04/godrays-for-mobile-devices</id>
    <content type="html"><![CDATA[<p>This time I want to talk about one of the best postprocess effect I saw in games. It&rsquo;s called <code>Godrays</code> or <code>Lightshafts</code> depents on people I&rsquo;m calling it godrays. Basically it&rsquo;s one of the most challenging effects due to it&rsquo;s horsepower consumption. Today i will show you how to implement low cost Godrays for your mobile game (or PC).</p>

<!--more-->


<p>After correct implementation you should see something like that:</p>

<p><img class="center" src="/assets/images/godrays_image.png" width="800"></p>

<p>Awesome isn&rsquo;t it? Everything you see comes from my custom 3D engine that i build some time ago and now i did some finetunings to see how much i can achieve with current mobile phones generation. Demo runs at stable 30FPS having godrays, shadows, full physic etc. If there are any heavy calculations im using dynamic viewport scalling to drop down pixels and save some CPU and GPU calculations.</p>

<p>But enought talking time to show some code, ah before we start keep in mind this is OpenGL ES 2.0 implementation and you can do it even better and faster using ES 3.0 which contains MRT (multiple render target) to save some render passes.</p>

<p>First we need to implement our FBO to store dynamic textures:</p>

<pre><code class="cpp">
#import &lt;Foundation/Foundation.h&gt;
#import &lt;OpenGLES/EAGL.h&gt;
#import &lt;OpenGLES/ES2/gl.h&gt;
#import &lt;OpenGLES/ES2/glext.h&gt;

#define glBindVertexArray glBindVertexArrayOES
#define glGenVertexArrays glGenVertexArraysOES
#define glDeleteVertexArrays glDeleteVertexArraysOES

#ifndef FBO_H
#define FBO_H
enum MRT_TYPE { FBO_2D_COLOR, FBO_CUBE_COLOR, FBO_2D_DEPTH, FBO_2D_DEPTH2 };

typedef struct {
    MRT_TYPE    type; 
    int         format; 
    GLenum      m_eAttachment;
    GLenum      eTarget;
} MRTLayer;

class FrameBufferObject {
public:
    MRTLayer own;

    FrameBufferObject();
    ~FrameBufferObject() {Destroy();}

    void Add(MRTLayer Current);
    bool CreateNormal(MRT_TYPE type, int format, GLuint width, GLuint height);
    bool CreateDepth(GLuint width, GLuint height);
    bool Create(GLuint width, GLuint height);
    void Destroy();

    void Begin(GLuint nFace);
    void End(GLuint nFace);

    void Bind(GLint unit, GLint index);
    void Unbind(GLint unit);

    GLuint getTextureHandle(int what)   {return m_nTexId;}
    GLuint getWidth()   {return m_nWidth;}
    GLuint getHeight()  {return m_nHeight;}
    bool   isError() {return !m_bUseFBO;}


    bool CheckStatus();
    GLuint      m_nTexId;

private:
    bool        m_bUseFBO;
    bool        m_bUseDepthBuffer;

    GLuint      m_nWidth, m_nHeight;
    GLuint      m_nFrameBufferHandle;
    GLuint      m_nDepthBufferHandle;
    GLenum      m_eTextureType;
    GLuint      m_oldBuffer;

};
#endif
</code></pre>

<p>It is acutally a cpp code because i port it from my old 3D Engine i did when i was working on windows.</p>

<pre><code class="cpp">#include "FrameBufferObject.h"

FrameBufferObject::FrameBufferObject()
{
    m_nFrameBufferHandle=0;
    m_nDepthBufferHandle=0;
    m_nTexId = 0;
    m_nWidth = 0;
    m_nHeight = 0;
    m_bUseFBO = true;
    m_oldBuffer = 0;
}

void FrameBufferObject::Destroy()
{
    glDeleteTextures(1, &amp;m_nTexId);
    glDeleteFramebuffers(1, &amp;m_nFrameBufferHandle);
    if(m_bUseDepthBuffer)
        glDeleteRenderbuffers(1, &amp;m_nDepthBufferHandle);

    m_nFrameBufferHandle=0;
    m_nDepthBufferHandle=0;
    m_nTexId = 0;
    m_nWidth = 0;
    m_nHeight = 0;
    m_bUseFBO = true;
}

void FrameBufferObject::Add(MRTLayer Current)
{
    own = Current;
}

void FrameBufferObject::Begin(GLuint nFace) 
{
    assert(nFace&lt;6);
    glViewport(0, 0, m_nWidth, m_nHeight);


        glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint *) &amp;m_oldBuffer);
        glBindFramebuffer(GL_FRAMEBUFFER, m_nFrameBufferHandle);

}

void FrameBufferObject::End(GLuint nFace) 
{
        glBindFramebuffer(GL_FRAMEBUFFER, m_oldBuffer);
}

void FrameBufferObject::Bind(GLint unit, GLint index) 
{
    glActiveTexture(GL_TEXTURE0 + unit);
    glEnable(m_eTextureType);
    glBindTexture(m_eTextureType, m_nTexId);
}

void FrameBufferObject::Unbind(GLint unit) 
{
    glActiveTexture(GL_TEXTURE0 + unit);
    glBindTexture( m_eTextureType, 0 );
    glDisable(m_eTextureType);
}

bool FrameBufferObject::Create(GLuint width, GLuint height){
    return false;
};

bool FrameBufferObject::CreateNormal(MRT_TYPE type, int format, GLuint width, GLuint height)
{
    own.type = type;
    own.format = format;
    Destroy();


    m_nWidth = width;
    m_nHeight = height;
    m_bUseFBO = true;
    m_bUseDepthBuffer = false;
    m_eTextureType = GL_TEXTURE_2D;

    //this is very important on mobile devices! you need to keep tracking
    //original FBO that iOS creates for you while rendering scene.
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint *) &amp;m_oldBuffer);


    glGenRenderbuffers(1, &amp;m_nDepthBufferHandle);
    glBindRenderbuffer(GL_RENDERBUFFER, m_nDepthBufferHandle);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);
    glBindRenderbuffer(GL_RENDERBUFFER, 0);

    glGenTextures(1, &amp;m_nTexId);
    glBindTexture(GL_TEXTURE_2D, m_nTexId);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
    glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0,  GL_RGBA , GL_UNSIGNED_BYTE, 0);
    glBindTexture(GL_TEXTURE_2D, 0);

    glGenFramebuffers(1, &amp;m_nFrameBufferHandle);
    glBindFramebuffer(GL_FRAMEBUFFER, m_nFrameBufferHandle);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_nTexId, 0);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_nDepthBufferHandle);

    CheckStatus();

    glBindFramebuffer(GL_FRAMEBUFFER, m_oldBuffer);


    return true;
}

bool FrameBufferObject::CreateDepth(GLuint width, GLuint height)
{

    m_nWidth = width;
    m_nHeight = height;

    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint *) &amp;m_oldBuffer);

    glGenTextures(1, &amp;m_nTexId);
    glBindTexture(GL_TEXTURE_2D, m_nTexId);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_STENCIL_OES, width, height, 
                 0,
                 GL_DEPTH_STENCIL_OES, 
                 GL_UNSIGNED_INT_24_8_OES, 
                 NULL);

    glBindTexture(GL_TEXTURE_2D, 0);

    glGenFramebuffers(1, &amp;m_nFrameBufferHandle);
    glBindFramebuffer(GL_FRAMEBUFFER, m_nFrameBufferHandle);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_nTexId, 0);

    CheckStatus();

    glBindFramebuffer(GL_FRAMEBUFFER, m_oldBuffer);

    return true;
}

bool FrameBufferObject::CheckStatus()
{

    switch(glCheckFramebufferStatus(GL_FRAMEBUFFER)) {
        case GL_FRAMEBUFFER_COMPLETE:
            NSLog(@"GL_FRAMEBUFFER_COMPLETE_EXT ");
            return true;
            break;

        case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            NSLog(@"GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT ");

            break;

        case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            NSLog(@"GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT ");

            break;
#if TARGET_OS_IPHONE    
        case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            NSLog(@"GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT ");

            break;
#endif
        case GL_FRAMEBUFFER_UNSUPPORTED:
            NSLog(@"GL_FRAMEBUFFER_UNSUPPORTED_EXT ");

            break;

    }

    return false;
}
</code></pre>

<p>Now we need some code that will help us render, find and transform sun position to screen space.</p>

<pre><code class="cpp">
//this should be somehow dynamic but it's tutorial so I'm hardcoding this :)
float GODRAY_X = 568;
float GODRAY_Y = 320;
float RETINA_SCALE = 2.0f;
float shaftX;
float shaftY;

static const GLfloat squareVertices[] = {
    -GODRAY_X, -GODRAY_Y,
    GODRAY_X, -GODRAY_Y,
    -GODRAY_X,  GODRAY_Y,
    GODRAY_X,  GODRAY_Y,
};

static const GLfloat textureVertices[] = {
    0.0f, 0.0f,
    1.0f, 0.0f,
    0.0f, 1.0f,
    1.0f, 1.0f,
}; 
</code></pre>

<p>Now create our FBO that will keep depth and 2 another that will compose the final image by blurring downscaled image.</p>

<pre><code class="cpp">
FrameBufferObject *FBO;
FrameBufferObject *BFBO;
FrameBufferObject *BFBO2;

FBO = new FrameBufferObject;
FBO-&gt;CreateDepth(GODRAY_X, GODRAY_Y);

BFBO = new FrameBufferObject;
BFBO-&gt;CreateNormal(FBO_2D_COLOR, GL_RGBA, GODRAY_X, GODRAY_Y);

BFBO2 = new FrameBufferObject;
BFBO2-&gt;CreateNormal(FBO_2D_COLOR, GL_RGBA, GODRAY_X, GODRAY_Y);
</code></pre>

<p>Remember to dispose resources in dealloc!</p>

<pre><code class="objc">- (void)dealloc
{
    FBO-&gt;Destroy();
    delete FBO;

    BFBO-&gt;Destroy();
    delete BFBO; 

    BFBO2-&gt;Destroy();
    delete BFBO2; 
}
</code></pre>

<p>Now time to prepare data, render objects to FBO and compose it to final image</p>

<pre><code class="objc">
void getLightScreenCoor(xVec3 light, float &amp;uniformLightX, float &amp;uniformLightY)
{
    int viewport[4] = {0, 0, GODRAY_X, GODRAY_Y};
    GLKVector3 msun = GLKVector3Make(light.x, light.y, light.z);
    GLKVector3 win = GLKMathProject(msun, 
                                    ModelView, 
                                    Projection, 
                                    viewport);
    uniformLightX = win.x/GODRAY_X;
    uniformLightY = win.y/GODRAY_Y;
}

- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect
{
    glClearColor(0.65f, 0.65f, 0.65f, 1.0f);

    FBO-&gt;Begin(0);
    {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    

        //render your objects here and store their depth   

        ...      
    }
    FBO-&gt;End(0);   

    glViewport(0, 0, rect.size.width*RETINA_SCALE, rect.size.height*RETINA_SCALE);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    //NOW RENDER YOUR DATA AGAIN TO OUTPUT FBO

    ...

    //PROPER LIGHTSHAFTS RENDERING

    //1st get sun direction vector, find it's position in 3D space and convert to 2D position
    xVec3 Sun = xVec3(-0.291719, -0.951882, -0.093922); 
    float sunsize = 1.23 * 9000 - 4000;
    Sun *= sunsize;

    //get 2D position
    getLightScreenCoor(Sun, shaftX, shaftY);

    Sun.normalize();
    float dotlight = eyeDirection.dot(Sun); //THIS IS USEFULL FOR CALCUALTING HOW MUCH GOD RAYS POSTPROCESS WE WANT TO APPLY

    Projection = GLKMatrix4MakeOrtho(-GODRAY_X, GODRAY_X, -GODRAY_Y, GODRAY_Y, 0.0, 1000.0);
    ModelView = GLKMatrix4Identity;

    glClear(GL_DEPTH_BUFFER_BIT);

    //NOW BUILD OUR SHAFTS TEXTURE

        //COMPUTE SHAFTS
        BFBO-&gt;Begin(0);
        {
            glUseProgram(ShaftShader-&gt;ShaderProgram);

            glActiveTexture(GL_TEXTURE0);
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, FBO-&gt;m_nTexId);
            glUniformMatrix4fv(ShaftShader-&gt;uniforms[UNI_PROJECTION_MAT], 1 ,false , Projection.m);
            glUniformMatrix4fv(ShaftShader-&gt;uniforms[UNI_MODELVIEW_WORLD_MAT], 1 ,false , ModelView.m);
            glUniform1i(ShaftShader-&gt;uniforms[UNI_TEX0],0);
            glUniform2f(ShaftShader-&gt;uniforms[UNI_SCREEN_POS], shaftX, shaftY);
            glUniform1f(ShaftShader-&gt;uniforms[UNI_DOT_LIGHT], dotlight);
            glUniform3fv(ShaftShader-&gt;uniforms[UNI_LIGHT_COLOR], 1, m_SunColor.get());

            glVertexAttribPointer(ATTRIB_VERTEX, 2, GL_FLOAT, 0, 0, squareVertices);
            glEnableVertexAttribArray(ATTRIB_VERTEX);
            glVertexAttribPointer(ATTRIB_COORDS, 2, GL_FLOAT, 0, 0, textureVertices);
            glEnableVertexAttribArray(ATTRIB_COORDS);

            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

        }
        BFBO-&gt;End(0);

        //BLUR VERTICALLY
        BFBO2-&gt;Begin(0);
        {
            glUseProgram(blurShaderY-&gt;ShaderProgram);

            glActiveTexture(GL_TEXTURE0);
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, BFBO-&gt;m_nTexId);
            glUniformMatrix4fv(blurShaderY-&gt;uniforms[UNI_PROJECTION_MAT], 1 ,false , Projection.m);
            glUniformMatrix4fv(blurShaderY-&gt;uniforms[UNI_MODELVIEW_WORLD_MAT], 1 ,false , ModelView.m);
            glUniform1i(blurShaderY-&gt;uniforms[UNI_TEX0],0);

            glVertexAttribPointer(ATTRIB_VERTEX, 2, GL_FLOAT, 0, 0, squareVertices);
            glEnableVertexAttribArray(ATTRIB_VERTEX);
            glVertexAttribPointer(ATTRIB_COORDS, 2, GL_FLOAT, 0, 0, textureVertices);
            glEnableVertexAttribArray(ATTRIB_COORDS);

            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
        }
        BFBO2-&gt;End(0);

        //BLUR HORIZONTALLY AND COMPOSE WITH CURRENT IMAGE

        glViewport(0, 0, rect.size.width*RETINA_SCALE, rect.size.height*RETINA_SCALE);

        glBlendFunc(GL_ONE, GL_ONE); //CHANGE TO ADDITIVE BLENDING

        glUseProgram(blurShaderX-&gt;ShaderProgram);

        glActiveTexture(GL_TEXTURE0);
        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, BFBO2-&gt;m_nTexId);
        glUniformMatrix4fv(blurShaderX-&gt;uniforms[UNI_PROJECTION_MAT], 1 ,false , Projection.m);
        glUniformMatrix4fv(blurShaderX-&gt;uniforms[UNI_MODELVIEW_WORLD_MAT], 1 ,false , ModelView.m);
        glUniform1i(blurShaderX-&gt;uniforms[UNI_TEX0],0);

        glVertexAttribPointer(ATTRIB_VERTEX, 2, GL_FLOAT, 0, 0, squareVertices);
        glEnableVertexAttribArray(ATTRIB_VERTEX);
        glVertexAttribPointer(ATTRIB_COORDS, 2, GL_FLOAT, 0, 0, textureVertices);
        glEnableVertexAttribArray(ATTRIB_COORDS);

        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

        //CHANGE BACK TO REGULAR BLEND
        glBlendFunc(GL_ONE,GL_ONE_MINUS_SRC_ALPHA);

}
</code></pre>

<p>Ok, so that&rsquo;s basically all about the code, now we need to talk about shaders beacause they are the 80% of our success here.</p>

<p>As you can see, im rendering to &frac14; of screen to reduce rendering time and pixel shader cost, but it will not look good. So that&rsquo;s why im using blurred image it will hide any glitches that are created by our shafts shader and there is another reason for that. I&rsquo;m using only 15 samples per frame which is terrible low (comparing typically you use around 30-50samples) and makes the screen looks very sharpy and ugly so thats another thing we need to hide. And there is ofcourse another cool feature: we can get some simplified HDRR by doing this.</p>

<p>Blur shaders are simple, you can find this implementation in many places:</p>

<p>HORIZONTAL:</p>

<pre><code class="glsl">attribute vec4 position;
attribute vec2 inputTextureCoordinate;
uniform mat4 projection;
uniform mat4 modelViewWorld;

varying vec2 vTexCoord;

void main()
{
    gl_Position = projection * modelViewWorld * position;
    vTexCoord = inputTextureCoordinate.xy;
}
</code></pre>

<pre><code class="glsl">uniform sampler2D RTScene; 
varying lowp vec2 vTexCoord;

const lowp float blurSize = 1.0/160.0; 

void main(void)
{
    mediump vec4 sum = vec4(0.0);

    sum += texture2D(RTScene, vec2(vTexCoord.x, vTexCoord.y - 4.0*blurSize)) * 0.05;
    sum += texture2D(RTScene, vec2(vTexCoord.x, vTexCoord.y - 3.0*blurSize)) * 0.09;
    sum += texture2D(RTScene, vec2(vTexCoord.x, vTexCoord.y - 2.0*blurSize)) * 0.12;
    sum += texture2D(RTScene, vec2(vTexCoord.x, vTexCoord.y - blurSize)) * 0.15;
    sum += texture2D(RTScene, vec2(vTexCoord.x, vTexCoord.y)) * 0.16;
    sum += texture2D(RTScene, vec2(vTexCoord.x, vTexCoord.y + blurSize)) * 0.15;
    sum += texture2D(RTScene, vec2(vTexCoord.x, vTexCoord.y + 2.0*blurSize)) * 0.12;
    sum += texture2D(RTScene, vec2(vTexCoord.x, vTexCoord.y + 3.0*blurSize)) * 0.09;
    sum += texture2D(RTScene, vec2(vTexCoord.x, vTexCoord.y + 4.0*blurSize)) * 0.05;

    gl_FragColor = sum;
}
</code></pre>

<p>VERTICAL:</p>

<pre><code class="glsl">attribute vec4 position;
attribute vec2 inputTextureCoordinate;
uniform mat4 projection;
uniform mat4 modelViewWorld;

varying vec2 vTexCoord;

void main()
{
    gl_Position = projection * modelViewWorld * position;
    vTexCoord = inputTextureCoordinate.xy;
}
</code></pre>

<pre><code class="glsl">uniform sampler2D RTBlurH; 
varying lowp vec2 vTexCoord;

const lowp float blurSize = 1.0/240.0;

void main(void)
{
    mediump vec4 sum = vec4(0.0);

    sum += texture2D(RTBlurH, vec2(vTexCoord.x - 4.0*blurSize, vTexCoord.y)) * 0.05;
    sum += texture2D(RTBlurH, vec2(vTexCoord.x - 3.0*blurSize, vTexCoord.y)) * 0.09;
    sum += texture2D(RTBlurH, vec2(vTexCoord.x - 2.0*blurSize, vTexCoord.y)) * 0.12;
    sum += texture2D(RTBlurH, vec2(vTexCoord.x - blurSize, vTexCoord.y)) * 0.15;
    sum += texture2D(RTBlurH, vec2(vTexCoord.x, vTexCoord.y)) * 0.16;
    sum += texture2D(RTBlurH, vec2(vTexCoord.x + blurSize, vTexCoord.y)) * 0.15;
    sum += texture2D(RTBlurH, vec2(vTexCoord.x + 2.0*blurSize, vTexCoord.y)) * 0.12;
    sum += texture2D(RTBlurH, vec2(vTexCoord.x + 3.0*blurSize, vTexCoord.y)) * 0.09;
    sum += texture2D(RTBlurH, vec2(vTexCoord.x + 4.0*blurSize, vTexCoord.y)) * 0.05;

    gl_FragColor = sum;
}
</code></pre>

<p>Now it is time for our main shader, it uses some tricks that allow you to reduce calculation cost:</p>

<pre><code class="glsl">attribute vec4 position;
attribute vec2 inputTextureCoordinate;

uniform mat4 projection;
uniform mat4 modelViewWorld;
uniform vec2 lightSS;

varying vec2 textureCoordinate;
varying vec2 lightScreen;

void main()
{

    gl_Position = projection * modelViewWorld * position;

    lightScreen = lightSS;
    textureCoordinate = inputTextureCoordinate.xy;
}
</code></pre>

<pre><code class="glsl">precision mediump float;

uniform lowp sampler2D myTexture;
uniform lowp float dotlight;
uniform vec3 lightColor;

varying lowp vec2 textureCoordinate;
varying lowp vec2 lightScreen;

//here you can manipulate strenght, distance, and final result but current values should be good enought.
#define Density 0.25
#define Weight 0.3
#define Decay 0.99
#define Exposure 0.15

float illum = 0.0;
float illuminationDecay = 1.0;
vec2 deltaTexCoord = vec2( 0.0 );
vec2 texCoordp = vec2( 0.0 );

//this value should have exacly same number of Sample_It() calls.
#define NUM_SAMPLES 15.0
const float InvNumSamples = 1.0 / NUM_SAMPLES ;

void Sample_It(){
    texCoordp -= deltaTexCoord;
    //we need to offset step due to low precision on mobile normaly you should use 1.0
    float sampled = step( 0.99995 , texture2D(myTexture,texCoordp.st).r );
    illum += sampled * illuminationDecay * Weight * dotlight;
    illuminationDecay *= Decay;
}

void main(){
    texCoordp = textureCoordinate;
    deltaTexCoord = ( texCoordp - lightScreen ) * InvNumSamples * Density; 

    illum = 0.0;
    illuminationDecay = 1.0;

    Sample_It(); //1
    Sample_It(); //2
    Sample_It(); //3
    Sample_It(); //4
    Sample_It(); //5
    Sample_It(); //6
    Sample_It(); //7
    Sample_It(); //8
    Sample_It(); //9
    Sample_It(); //10
    Sample_It(); //11
    Sample_It(); //12
    Sample_It(); //13
    Sample_It(); //14
    Sample_It(); //15

    gl_FragColor = vec4( vec3( illum * Exposure ) * lightColor, 1.0 );

}
</code></pre>

<p>And voila! this will generate image with applied shafts to it. Ok so how it acutally works? <br/>
-You look at depth pixel by pixel  <br/>
-And check if the distance of it is bigger than specified offset (remember GPU saves depth as 0-1)   <br/>
-If there is any object on our way it will return 0 color so we have black pixel there     <br/>
-Otherwise white as we are poiting to infinity, multipled by specified color <br/>
-Repeat this N times (here I&rsquo;m using 15 samples but you may try to modify this eg on iPhone 4S i was using only 10samples ) <br/>
-Each time you repeat shift the result by specified direction vector (our sun position in screen space)</p>

<p>This image should explain this good enought:</p>

<p><img class="center" src="/assets/images/lightshafts-explain.jpg" width="800"></p>

<p>Here we can see final result:</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/w6TJuDb0XDo" allowfullscreen></iframe></div></p>

<p>And that&rsquo;s quiet everything i have today, next time again iOS8 ;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UIButton backgroundColor you do it wrong...]]></title>
    <link href="http://noxytrux.github.io/blog/2014/09/25/ios-uibutton-backgroundcolor-you-do-it-wrong-dot-dot-dot/"/>
    <updated>2014-09-25T16:21:30+02:00</updated>
    <id>http://noxytrux.github.io/blog/2014/09/25/ios-uibutton-backgroundcolor-you-do-it-wrong-dot-dot-dot</id>
    <content type="html"><![CDATA[<p>This post is for those who are just starting they journey with iOS and Swift and want to learn some good practices on how to build this nice looking flat UI in modern iOS. Basically i want to talk about rectangle buttons that are filled with color. I saw some really bad implementations of <code>UIButton</code> and now, I want to present you a common mistake, i ofen see in many project even those mature ones.</p>

<!--more-->


<p>This image descibes our tutorial code, we have two button first one is done in bad habit and uses backgroundcolor and second one is done using background image property.</p>

<p><img class="center" src="/assets/images/look_buttons.png" width="300"></p>

<p>Basically backgroundColor property is good thing to use in Interface Builder to see how the button will looks like. But if you try to manage states you will end up with something like this:</p>

<pre><code class="Ruby">
@IBAction func buttonHightlight(sender: UIButton!) {

    sender.backgroundColor = UIColor(red: 255.0/255.0, green: 81.0/255.0, blue: 85.0/255.0, alpha: 0.5)    
}

@IBAction func buttonNormal(sender: UIButton!) {

    sender.backgroundColor = UIColor(red: 255.0/255.0, green: 81.0/255.0, blue: 85.0/255.0, alpha: 1.0)
}
</code></pre>

<p>It is event worst because your states in IB looks very similar to this:</p>

<p><img class="center" src="/assets/images/selector_ohno.png" width="300"></p>

<p>Madness and disaster, seriously that&rsquo;s not how you want to build your button, highlight state is build in and it&rsquo;s for free. And of course you only want to call function reponsible for pressing button no additional ones.</p>

<p>To do that we should use backgroundImage property of <code>UIButton</code>, but to not generate any additional assets let&rsquo;s build two extensions. First one will be reponsibe for generating <code>UIImage</code> from <code>UIColor</code> so we can set it directly from code.</p>

<pre><code class="Ruby">
import UIKit

extension UIImage {

    class func imageWithColor(color:UIColor?) -&gt; UIImage! {

        let rect = CGRectMake(0.0, 0.0, 1.0, 1.0);

        UIGraphicsBeginImageContextWithOptions(rect.size, false, 0)

        let context = UIGraphicsGetCurrentContext();

        if let color = color {

            color.setFill()
        }
        else {

            UIColor.whiteColor().setFill()
        }

        CGContextFillRect(context, rect);

        let image = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();

        return image;
    }

}
</code></pre>

<p>Second one is not required but is very usefull, and allow you to copy and paste color from eg gimp or photoshop. We are talking about UIColor extension that allow us to use hexadecimal strings as input value.</p>

<pre><code class="Ruby">
import UIKit

extension UIColor {

    class func colorWithHex(hexString: String?) -&gt; UIColor? {

        return colorWithHex(hexString, alpha: 1.0)
    }

    class func colorWithHex(hexString: String?, alpha: CGFloat) -&gt; UIColor? {

        if let hexString = hexString {

            var error : NSError? = nil

            let regexp = NSRegularExpression(pattern: "\\A#[0-9a-f]{6}\\z",
                options: .CaseInsensitive,
                error: &amp;error)

            let count = regexp.numberOfMatchesInString(hexString,
                options: .ReportProgress,
                range: NSMakeRange(0, countElements(hexString)))

            if count != 1 {

                return nil
            }

            var rgbValue : UInt32 = 0

            let scanner = NSScanner(string: hexString)

            scanner.scanLocation = 1
            scanner.scanHexInt(&amp;rgbValue)

            let red   = CGFloat( (rgbValue &amp; 0xFF0000) &gt;&gt; 16) / 255.0
            let green = CGFloat( (rgbValue &amp; 0xFF00) &gt;&gt; 8) / 255.0
            let blue  = CGFloat( (rgbValue &amp; 0xFF) ) / 255.0

            return UIColor(red: red, green: green, blue: blue, alpha: alpha)
        }

        return nil
    }

}
</code></pre>

<p>And that&rsquo;s it, so how do we set our good button ? like this:</p>

<pre><code class="Ruby">
//good button...
goodButton.backgroundColor = UIColor.clearColor() //reset IB Color
goodButton.setBackgroundImage(UIImage.imageWithColor(UIColor.colorWithHex("#66D269")), forState: .Normal)
goodButton.setBackgroundImage(UIImage.imageWithColor(UIColor.colorWithHex("#66D269", alpha: 0.5)), forState: .Highlighted)
</code></pre>

<p>So reassuming, do not use <code>IBAction</code> to modify button color, hightlight state etc. Use backgroundImage and if you don&rsquo;t want to use assets build them from code using extensions. As always <a href="https://github.com/noxytrux/ButtonsGoodPracticeTutorial">source code</a> on my github page.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 Weirdness Part3: Laggy UICollectionView]]></title>
    <link href="http://noxytrux.github.io/blog/2014/09/25/ios8-weirdness-part3-laggy-uicollectionview/"/>
    <updated>2014-09-25T10:03:36+02:00</updated>
    <id>http://noxytrux.github.io/blog/2014/09/25/ios8-weirdness-part3-laggy-uicollectionview</id>
    <content type="html"><![CDATA[<p>Autolayouts, something that people love and hate. When Apple introduced them i had mixed felling about it, from one hand it reduces tons of code, also do a lot of calculation for you and of course it magically works! In other hand&hellip; it is terribly slow i still see my manual <code>setFrame:</code> at least 10 times faster than calculation something in AL but nothing for free.</p>

<!--more-->


<p></p>

<p>This post will not be long, the main problem is that as most of you may know using autolayout in scrollview is pain in ass terrible slow due to continous autolayout recalculation mostly if you use xib loaded view with AL attached to them. So why not to use UICollectionView better, faster, bigger, stronger. I have heavy collection view with very complicated cells (in terms of autolayout) but they are done pretty smart and work really fast and smooth, of course only in iOS7</p>

<p>After updating my ipad to iOS8 i encounter terrible lags while scrolling <code>UICollectionView</code> in my app. Again instruments bug haunting with tons of coffee shows me that my amazing <code>UICollectionView</code> starts acting exacly like ugly <code>UIScrollView</code> solution and recalculates cells autolayout over and over again!</p>

<p><img class="center" src="/assets/images/ohcomone.gif"></p>

<p>Gladly solution to that is pretty simple. If you watched <a href="https://developer.apple.com/videos/wwdc/2014/">WWDC 2014</a> about changes in collection view you propably noticed that Apple introduces some new Invaidation Context etc. But we do not need to implement all of that if you want to get your smooth and nice scrolling the only thing you need is to implement this method in your custom <code>UICollectionViewCell</code></p>

<pre><code class="objc">
- (UICollectionViewLayoutAttributes *)preferredLayoutAttributesFittingAttributes:(UICollectionViewLayoutAttributes *)layoutAttributes
{
    return layoutAttributes;
}
</code></pre>

<p>And you are done! Collection view again works as expected, it happens because this is called before autolayout calcualtion and it returns proper cell size so there is no need to trigger recalcualtion again. You should see some visual changes eg collection view cell will no more weirdly rescale from 1x1 to it desired scale.</p>

<p>That&rsquo;s all for now, next time some UIButton good practices for those who just start coding in iOS and want their flat buttons looks and works good.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 Weirdness Part2: Modal ViewController]]></title>
    <link href="http://noxytrux.github.io/blog/2014/09/24/ios8-weirdness-part2-modal-viewcontroller/"/>
    <updated>2014-09-24T16:49:51+02:00</updated>
    <id>http://noxytrux.github.io/blog/2014/09/24/ios8-weirdness-part2-modal-viewcontroller</id>
    <content type="html"><![CDATA[<p>As i promised we are continuing werid iOS8 bugs i encounter after update. Last one was funny but this one is a masterpiece. Imagine you have project where your user can type some values eg. add contact, some place or something. We want to help our user by giving him some hints while typing or some predefinied values he can choose from. It is a good idea to present this kind of view as a modal view controller&hellip;</p>

<!--more-->


<p>Imagine my reaction to my stable iOS7 code when my QA guy come to me and said something like this:</p>

<p>&ldquo;Why all our modal view controllers can close by themselves, i mean look if you dismiss popover on that modal view it will close.&rdquo;</p>

<p><img class="right" src="/assets/images/whatthehell.gif"></p>

<p>Sounds quiet funny right? How the hell modally showed <code>UIViewController</code> can close just like that without pressing anything. But after few hours of debbuging i was not so happy it actually happend to me! All the time i was dimissing <code>UIPopoverController</code> the modal view was dimissing with this popover! But there is a trick behing this you need to set your view stack like this:</p>

<p><code>UINavigationViewController</code> that holds <code>UIViewController</code> and from here you can open modal <code>UIViewController</code> that contains some containers. In some big project im participating we have some reusable ViewControllers that doing specific things one of it is <code>UIViewController</code> with <code>UITextField</code> in it. If you press on that <code>UITextField</code> a popover will show to help you choose / find some value. So this is how our app looks / works:</p>

<p><img class="center" src="/assets/images/modalOK.gif" width="800"></p>

<p>Pretty simple, so the app opens some modal view and contains this funny component. Ofc this code works fine on iOS7, now if we run this on iOS8 we will see somethings like this:</p>

<p><img class="center" src="/assets/images/modalBAD.gif" width="800"></p>

<p>So wherever user tap outside to dismiss <code>UIPopoverController</code> (i created it from code to avoid <a href="http://noxytrux.github.io/blog/2014/09/17/ios8-weirdness-part1-uipopovercontroller/">latest</a> issues) modal controller also dimiss&hellip; It took me some cups of coffet to recognize what is wrong but before that let&rsquo;s see some code that is responsible for this. I will not describe whole example code just the green <code>UIViewController</code> that is placed using container segue.</p>

<pre><code class="objc">#import "MWLContainerViewController.h"
#import "MWLCitiesTableViewController.h"

@interface MWLContainerViewController ()
&lt;UITextFieldDelegate,
UIPopoverControllerDelegate,
MWLCitiesTableViewControllerDelegate&gt;

@property (nonatomic, weak) IBOutlet UITextField *typeCityTextField;
@property (nonatomic, strong) UIPopoverController *searchPopoverController;
@property (assign, nonatomic, getter = isKeyboardVisible) BOOL keyboardVisible;
@property (nonatomic, weak) MWLCitiesTableViewController *selectionController;

@end

@implementation MWLContainerViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.typeCityTextField.delegate = self;
}

- (void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardDidShow:)
                                                 name:UIKeyboardDidShowNotification
                                               object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardDidHide:)
                                                 name:UIKeyboardDidHideNotification
                                               object:nil];
}

- (void)viewDidDisappear:(BOOL)animated
{
    [super viewDidDisappear:animated];

    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

-(void)keyboardDidShow:(NSNotification *)notification
{
    self.keyboardVisible = YES;

    if(self.typeCityTextField.editing) {

        [self showControllerIfNeeded:self.typeCityTextField];
    }
}

-(void)keyboardDidHide:(NSNotification *)notification
{
    self.keyboardVisible = NO;
}

- (void)showControllerIfNeeded:(UIView *)sender
{
    if(self.searchPopoverController.popoverVisible == NO &amp;&amp; self.keyboardVisible == YES) {

        self.searchPopoverController = [self itemSelectionPopover];
        [self.searchPopoverController presentPopoverFromRect:sender.bounds
                                                      inView:sender
                                    permittedArrowDirections:UIPopoverArrowDirectionDown
                                                    animated:YES];
    }
}

- (UIPopoverController *)itemSelectionPopover
{
    MWLCitiesTableViewController *cityController = [self.storyboard instantiateViewControllerWithIdentifier:kMWLSegueControllerIdentifier];
    self.selectionController = cityController;
    self.selectionController.delegate = self;

    UIPopoverController *popoverController = [[UIPopoverController alloc] initWithContentViewController:cityController];

    popoverController.delegate = self;
    popoverController.popoverContentSize = CGSizeMake(300, 400);

    return popoverController;
}

#pragma mark - UITextFieldDelegate

- (void)textFieldDidBeginEditing:(UITextField *)textField
{
    self.typeCityTextField.clearsOnInsertion = YES;

    [self showControllerIfNeeded:textField];
}

- (void)textFieldDidEndEditing:(UITextField *)textField
{
    [self.searchPopoverController dismissPopoverAnimated:YES];
}

- (BOOL)textFieldShouldReturn:(UITextField *)textField
{
    [textField resignFirstResponder];

    return YES;
}

#pragma mark - UIPopoverControllerDelegate

- (void)popoverControllerDidDismissPopover:(UIPopoverController *)popoverController
{
    //delegate down
}

- (BOOL)popoverControllerShouldDismissPopover:(UIPopoverController *)popoverController
{
    [self.typeCityTextField resignFirstResponder];

    return YES;
}

#pragma mark - MWLCitiesTableViewControllerDelegate

- (void)citiesTableView:(MWLCitiesTableViewController *)sender
          didSelectCity:(NSString *)cityName
{
    self.typeCityTextField.text = cityName;
    [self.typeCityTextField resignFirstResponder];
}

@end
</code></pre>

<p>Ok so we have view controller that hold <code>UITextField</code> and <code>UIPopoverController</code> and opens it when user focus on the textfield. Popover will close if:</p>

<p>a) User enter something and hide keyboard using hide key (bottom right corner)  <br/>
b) User will press return button on keyboard <br/>
c) User will select some value from popover <br/>
d) User will tap outside to dimiss popover</p>

<p>Every seems to work fine except the last scenario where user tap outside to cancel and hide popover. So it is again connected with <code>UIPopoverController</code> delegate methods as option a, b, c closes popover from code using <code>[self.searchPopoverController dismissPopoverAnimated:YES];</code> and as we all know popover delegate methods are called ONLY if you close popover by touching outside of it. Moving forward if you look closely you will recognize that when this code executes</p>

<pre><code class="objc">
- (BOOL)popoverControllerShouldDismissPopover:(UIPopoverController *)popoverController
{
    [self.typeCityTextField resignFirstResponder];

    return YES;
}
</code></pre>

<p>we are acutally calling this</p>

<pre><code class="objc">
- (void)textFieldDidEndEditing:(UITextField *)textField
{
    [self.searchPopoverController dismissPopoverAnimated:YES];
}
</code></pre>

<p>before we leave function, so in iOS8 we are trying to close already closing popover, why this code works on iOS7? maybe there is difference in responder chain so that&rsquo;s why we are passing dimiss command down in responder. If you not belive me try and set break point in viewDidDisappear :) Reassuming to fix this isse we need to change this line:</p>

<pre><code class="objc">
- (BOOL)popoverControllerShouldDismissPopover:(UIPopoverController *)popoverController
{
    [self.typeCityTextField resignFirstResponder];

    return NO; //YES; 
}
</code></pre>

<p>So there is no more duplicated dimiss command moving around in our view. Acutally in this example we are alwasy sure that we call <code>textFieldDidEndEditing</code> no matter user do. But if you ever encounter some stupid , weird behaviours of your modal views you should first look at reponder chain logic.</p>

<p>That&rsquo;s it, <a href="https://github.com/noxytrux/iOS8ModalViewIssue">source code</a> as always available on my github page. Next time another iOS8 issue that helps us develop &ldquo;better&rdquo; code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 Weirdness part1: UIPopoverController]]></title>
    <link href="http://noxytrux.github.io/blog/2014/09/17/ios8-weirdness-part1-uipopovercontroller/"/>
    <updated>2014-09-17T11:18:09+02:00</updated>
    <id>http://noxytrux.github.io/blog/2014/09/17/ios8-weirdness-part1-uipopovercontroller</id>
    <content type="html"><![CDATA[<p>As and old wolf programmer with years of expirence in iOS I survive most of big iOS updates including switch from 4.2 to 5, from 5 to 6 and so on. Some people remember time when your app was able to work fine on all iOS verions, but all of that changes with iOS7 it makes a big change to how app are made. There is no more easy way to support iOS6 and iOS7 in one app. Apple make new iOS7 API really cool, now we have truly working Interface Builder, StoryBoards, Autolayouts etc. Making apps was never easier before. iOS8 looks event almost the same, so what could possibly go wrong?&hellip;</p>

<!--more-->


<p>Actually, a lot of things&hellip; But you say: &ldquo;oh comone, it not so bad at all. The era of dirty hacks is away!&rdquo; - NOPE.</p>

<p>With iOS8 Apple introduced new way to handle <code>UIAlert</code>, <code>UIActionSheet</code> and <code>UIPopoverController</code> by introducing brand new <code>UIPopoverPresentationController</code> and <code>UIAlertController</code>, but as we all know sometimes when you build big app that is developed for few months it is not an easy decision to drop support for specified iOS version&hellip; So let&rsquo;s support both! Of course we are not allowed to use new stuff, we still want our app to support iOS7 so we are not touching our code in terms of rewriting to new popovers and alerts.</p>

<p>If you prefer setuping popovers from code this article is not propably for you but if you are &ldquo;modern&rdquo; like me and you cannot anymore live without storyboards and segues you will be suprised what amazing new &ldquo;features&rdquo; iOS8 may bring to your iPad Application. Imagine this scenario: You are building your iPad app which require from you to select some values, so the natural way to handle that is to present data set in popover. Now let&rsquo;s say my app is some kind of alarm app so i need to setup and display time. I build my app and it works like a harm, no rocket sience here it&rsquo;s a simple one view controller app that fire up UIStoryBoardPopoverSegue when button gets pressed. The image explain app flow (look carefuly your popover segue is now set as deprecated in xCode 6 coz you should use new one which we can&rsquo;t use due to iOS7 support) so the app will works as described below:</p>

<p><img class="center" src="/assets/images/appflowpopovers.png" width="800"></p>

<p>a) User can press &ldquo;Set my date!&rdquo; button which opens Popover with DatePicker (sets &lsquo;now&rsquo; if date does not exist)<br/>
b) User can select date <br/>
c) By dimissing popover user is able to set new date<br/>
d) If user press button again popover will open with latest date selected</p>

<p>If we run the app on iOS7 this is what we will get:</p>

<p><img class="center" src="/assets/images/popoversOK.gif" width="800"></p>

<p>Ok time for some code, honestly there not to much to explain. First let&rsquo;s see how do we implement our DatePicker Controller:</p>

<pre><code class="objc">
#import &lt;UIKit/UIKit.h&gt;

@interface LABDateViewController : UIViewController

@property (nonatomic, strong) NSDate *date;
@property (nonatomic, weak) IBOutlet UIDatePicker *datePicker;

@end
</code></pre>

<p>So regular UIViewController with UIDatePicker attached via Outlet, now let&rsquo;s see what does it actually do:</p>

<pre><code class="objc">
#import "LABDateViewController.h"

@implementation LABDateViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    [self.datePicker addTarget:self
                        action:@selector(didChangeDate:)
              forControlEvents:UIControlEventValueChanged];
}

- (NSDate *)date
{
    return self.datePicker.date;
}

- (void)setDate:(NSDate *)date
{
    [self.datePicker setDate:date animated:YES];
}

- (void)didChangeDate:(UIDatePicker *)picker
{
    //send date somewhere, update, watewa
}

@end
</code></pre>

<p>As we can expected not to much it is very simple VC that only sets and gets seleted date by overwriting setter and getter of our date property.</p>

<p>Now the main logic:</p>

<pre><code class="objc">
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ( [segue.identifier isEqualToString:LABDisplayTimePopoverSegueIdentifier]) {

        if (!self.currentDate) {

            self.currentDate = [NSDate date];
        }

        UIStoryboardPopoverSegue *popover = (UIStoryboardPopoverSegue*)segue;
        popover.popoverController.delegate = self;

        LABDateViewController *c = (LABDateViewController *)popover.popoverController.contentViewController;

        [c.datePicker setDate:self.currentDate animated:YES];
    }
}

#pragma mark - popover delegate

- (BOOL)popoverControllerShouldDismissPopover:(UIPopoverController *)popoverController;
{
    return YES;
}

- (void)popoverControllerDidDismissPopover:(UIPopoverController *)popoverController
{
    //update title
    LABDateViewController *vc = (LABDateViewController*)popoverController.contentViewController;

    self.currentDate = vc.date;

    NSAssert(self.currentDate != nil, @"Upsss...");

    NSString *title = [self.dateFormatter stringFromDate:self.currentDate];

    [self.dateButton setTitle:title
                     forState:UIControlStateNormal];
}
</code></pre>

<p>As I said not much to explain simply we are passing date if exist to our created <code>UIPopoverController</code> which is supplied by <code>UIStoryboardPopoverSegue</code> at the moment we pressed button. We also set ourselfs as delegate so we can respond to popover dimiss. So after it disappear we can set currently selected value and update button title.</p>

<p>Now guess what happens if you try to run this on iOS8 Device / Simulator ? Yes it will stop working :) Value will not update, button title will stay the same, basically madness and tons of WTF per minute.</p>

<p><img class="center" src="/assets/images/popoversError.gif" width="800"></p>

<p>So where is the problem ? If you set breakpoint in any of delegate methods you will see that they are actually not called, not at all&hellip; So the next line that we may be interested is:</p>

<pre><code class="objc">UIStoryboardPopoverSegue *popover = (UIStoryboardPopoverSegue*)segue;
popover.popoverController.delegate = self;
</code></pre>

<p>Setting the actual delegate, looks fine even if you go deeper and check StoryboardSegue you will see this:</p>

<pre><code class="objc">#import &lt;UIKit/UIStoryboardSegue.h&gt;

@class UIPopoverController;

NS_CLASS_AVAILABLE_IOS(5_0) @interface UIStoryboardPopoverSegue : UIStoryboardSegue {
}

@property (nonatomic, retain, readonly) UIPopoverController *popoverController;

@end
</code></pre>

<p>So it looks like <code>UIPopoverController</code> is retained and all is ok! The truth is that is not, i cannot explain why is this happening but after we assign our delegate the connection is droped like the popover has weak reference in the segue&hellip; The way to fix that without doing whole loading from code is to simply assing popover to strong variable, so the quick fix for that is:</p>

<pre><code class="objc">
@interface LABViewController () &lt;UIPopoverControllerDelegate&gt;

@property (weak, nonatomic) IBOutlet UIButton *dateButton;
@property (strong, nonatomic) NSDate *currentDate;
@property (strong, nonatomic) NSDateFormatter *dateFormatter;
@property (strong, nonatomic) UIPopoverController *chooseTimePopover;

@end
</code></pre>

<p>And in our segue:</p>

<pre><code class="objc">
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ( [segue.identifier isEqualToString:LABDisplayTimePopoverSegueIdentifier]) {

        if (!self.currentDate) {

            self.currentDate = [NSDate date];
        }

        UIStoryboardPopoverSegue *popover = (UIStoryboardPopoverSegue*)segue;
//        popover.popoverController.delegate = self;
        self.chooseTimePopover = popover.popoverController;
        self.chooseTimePopover.delegate = self;

        LABDateViewController *c = (LABDateViewController *)popover.popoverController.contentViewController;

        [c.datePicker setDate:self.currentDate animated:YES];
    }
}
</code></pre>

<p>if you compile this, you will notice that delegate methods are now finally called so one win achieved!, title is updating but&hellip; Oh wait why every time i open popover the date is the same ?! Yes we are half done here in iOS7 at the segue all VC are loaded. In iOS8 viewDidLoad is called after segue, so if you will set breakpoint in this line:</p>

<pre><code class="objc">[c.datePicker setDate:self.currentDate animated:YES];

//by doing in lldb

po c.datePicker 

//you should get 

nil
</code></pre>

<p>So we need one final workaround for this, and there are 2 ways to do that first one:</p>

<p>If you VC do not need to load many variables its a good idea to set some temporary variable that will store the date as long as the viewDidLoad is not called.</p>

<p>Second one:</p>

<p>If you are lazy or you just don&rsquo;t want to change all your code you can do simple trick forcing view to load by putting this line:</p>

<pre><code class="objc">__unused UIView *view = c.view; // or (void)c.view;
</code></pre>

<p>So the final code will looks like that:</p>

<pre><code class="objc">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ( [segue.identifier isEqualToString:LABDisplayTimePopoverSegueIdentifier]) {

        if (!self.currentDate) {

            self.currentDate = [NSDate date];
        }

        UIStoryboardPopoverSegue *popover = (UIStoryboardPopoverSegue*)segue;
//        popover.popoverController.delegate = self;
        self.chooseTimePopover = popover.popoverController;
        self.chooseTimePopover.delegate = self;

        LABDateViewController *c = (LABDateViewController *)popover.popoverController.contentViewController;

        __unused UIView *view = c.view; // or (void)c.view;

        [c.datePicker setDate:self.currentDate animated:YES];
    }
}
</code></pre>

<p>This should fix all the issues related above :) hope some of you will find this helpfull. If you want to test this by yourself, here is the link to <a href="https://github.com/noxytrux/iOS8PopoverIssue">source code</a></p>

<p>Keep in mind this is not an elegant solution, it is more like a temporary workaround for the issue. If you cannot rewrite your segues to <code>UIPopoverPresentationController</code> it is a good idea to put popover loading back to code or use some additional variables in contentViewController to keep your code clean. We can always wait until Apple will put some fix for that.</p>

<p>Ok that&rsquo;s all for today, next time another funny iOS8 problem i encounter during my regular day work.</p>
]]></content>
  </entry>
  
</feed>
